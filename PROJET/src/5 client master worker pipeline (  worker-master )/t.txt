client.c:// client.c — version minimale FIFO + sémaphore mutex
client.c:
client.c:#if defined HAVE_CONFIG_H
client.c:#include "config.h"
client.c:#endif
client.c:
client.c:#include <fcntl.h>
client.c:#include <stdio.h>
client.c:#include <stdlib.h>
client.c:#include <string.h>
client.c:#include <sys/ipc.h>
client.c:#include <sys/sem.h>
client.c:#include <unistd.h>
client.c:
client.c:#include "master_client.h"
client.c:#include <assert.h>
client.c:#define TK_STOP "stop"
client.c:#define TK_COMPUTE "compute"
client.c:#define TK_HOW_MANY "howmany"
client.c:#define TK_HIGHEST "highest"
client.c:#define TK_LOCAL "local"
client.c:
client.c:static void usage(const char *exeName, const char *message) {
client.c:  fprintf(stderr, "usage : %s <ordre> [<nombre>]\n", exeName);
client.c:  fprintf(stderr, "   ordre \"" TK_STOP "\" : arrêt master\n");
client.c:  fprintf(stderr, "   ordre \"" TK_COMPUTE "\" : calcul de nombre premier\n");
client.c:  fprintf(stderr, "                       <nombre> doit être fourni\n");
client.c:  fprintf(stderr, "   ordre \"" TK_HOW_MANY
client.c:                  "\" : combien de nombres premiers calculés\n");
client.c:  fprintf(stderr, "   ordre \"" TK_HIGHEST
client.c:                  "\" : quel est le plus grand nombre premier calculé\n");
client.c:  fprintf(stderr,
client.c:          "   ordre \"" TK_LOCAL "\" : calcul de nombres premiers en local\n");
client.c:  if (message != NULL) fprintf(stderr, "message : %s\n", message);
client.c:  exit(EXIT_FAILURE);
client.c:}
client.c:
client.c:static int parseArgs(int argc, char *argv[], int *number) {
client.c:  int order = ORDER_NONE;
client.c:
client.c:  if ((argc != 2) && (argc != 3))
client.c:    usage(argv[0], "Nombre d'arguments incorrect");
client.c:
client.c:  if (strcmp(argv[1], TK_STOP) == 0)
client.c:    order = ORDER_STOP;
client.c:  else if (strcmp(argv[1], TK_COMPUTE) == 0)
client.c:    order = ORDER_COMPUTE_PRIME;
client.c:  else if (strcmp(argv[1], TK_HOW_MANY) == 0)
client.c:    order = ORDER_HOW_MANY_PRIME;
client.c:  else if (strcmp(argv[1], TK_HIGHEST) == 0)
client.c:    order = ORDER_HIGHEST_PRIME;
client.c:  else if (strcmp(argv[1], TK_LOCAL) == 0)
client.c:    order = ORDER_COMPUTE_PRIME_LOCAL;
client.c:
client.c:  if (order == ORDER_NONE) usage(argv[0], "ordre incorrect");
client.c:  if ((order == ORDER_STOP) && (argc != 2))
client.c:    usage(argv[0], TK_STOP " : il ne faut pas de second argument");
client.c:  if ((order == ORDER_COMPUTE_PRIME) && (argc != 3))
client.c:    usage(argv[0], TK_COMPUTE " : il faut le second argument");
client.c:  if ((order == ORDER_HOW_MANY_PRIME) && (argc != 2))
client.c:    usage(argv[0], TK_HOW_MANY " : il ne faut pas de second argument");
client.c:  if ((order == ORDER_HIGHEST_PRIME) && (argc != 2))
client.c:    usage(argv[0], TK_HIGHEST " : il ne faut pas de second argument");
client.c:  if ((order == ORDER_COMPUTE_PRIME_LOCAL) && (argc != 3))
client.c:    usage(argv[0], TK_LOCAL " : il faut le second argument");
client.c:  if ((order == ORDER_COMPUTE_PRIME) || (order == ORDER_COMPUTE_PRIME_LOCAL)) {
client.c:    *number = strtol(argv[2], NULL, 10);
client.c:    if (*number < 2) usage(argv[0], "le nombre doit être >= 2");
client.c:  }
client.c:
client.c:  return order;
client.c:}
client.c:
client.c:int main(int argc, char *argv[]) {
client.c:  // --- Récupération du mutex ---
client.c:  int key_mutex = ftok("master.c", 'M');
client.c:  int sem_mutex = semget(key_mutex, 1, 0666);
client.c:  assert(sem_mutex != -1);
client.c:
client.c:  int number = 0;
client.c:  int order = parseArgs(argc, argv, &number);
client.c:
client.c:  if (order == ORDER_COMPUTE_PRIME_LOCAL) {
client.c:    printf("[CLIENT] Local mode no master\n");
client.c:    return 0;
client.c:  }
client.c:
client.c:  // --- SECTION CRITIQUE ---
client.c:  P(sem_mutex); //je prend comme sa aucun autre client peut etre en section critique
client.c:
client.c:  int fdOut = open(FIFO_CLIENT_TO_MASTER, O_WRONLY);
client.c:  write(fdOut, &order, sizeof(order));
client.c:
client.c:  if (order == ORDER_COMPUTE_PRIME) write(fdOut, &number, sizeof(number));
client.c:
client.c:  close(fdOut);
client.c:
client.c:  int fdIn = open(FIFO_MASTER_TO_CLIENT, O_RDONLY);
client.c:
client.c:  int resultat = 0;
client.c:  read(fdIn, &resultat, sizeof(resultat));
client.c:  close(fdIn);
client.c:
client.c:  V(sem_mutex);//je vend pour qu'un autre client puisse rentré en session critique
client.c:  // --- FIN SECTION CRITIQUE ---
client.c:
client.c:  clientInterpretOrder(order, number, resultat);
client.c:  return 0;
client.c:}
Makefile:CC = gcc
Makefile:CFLAGS = -g -Wall -Wextra -pedantic -std=c99
Makefile:
Makefile:all: master client worker
Makefile:
Makefile:master: master.c
Makefile:	$(CC) $(CFLAGS) master.c master_client.c -o master.o
Makefile:
Makefile:client: client.c
Makefile:	$(CC) $(CFLAGS) client.c master_client.c -o client.o
Makefile:
Makefile:worker: worker.c
Makefile:	$(CC) $(CFLAGS) worker.c master_worker.c -o worker.o
Makefile:
Makefile:clean:
Makefile:	rm -f *.o *.fifo
master.c:// master.c — version corrigée (pipeline Hoare + non-blocking + STOP correct)
master.c:
master.c:#include <assert.h>
master.c:#include <fcntl.h>
master.c:#include <stdio.h>
master.c:#include <stdlib.h>
master.c:#include <sys/ipc.h>
master.c:#include <sys/sem.h>
master.c:#include <sys/stat.h>
master.c:#include <unistd.h>
master.c:
master.c:#include "master_client.h"
master.c:
master.c:// Données globales
master.c:int last_tested = 2;
master.c:int highest_prime = 2;
master.c:int nb_primes = 0;
master.c:
master.c:/* ============================================================
master.c: * Fonction utilitaire : passer un fd en NON-BLOCKING
master.c: * ============================================================ */
master.c:static void set_nonblocking(int fd) {
master.c:  int flags = fcntl(fd, F_GETFL, 0);
master.c:  fcntl(fd, F_SETFL, flags | O_NONBLOCK);
master.c:}
master.c:
master.c:/* ============================================================
master.c: * order_compute() — envoie un nombre au pipeline et récupère
master.c: * le résultat final SANS bloquer.
master.c: * ============================================================ */
master.c:int order_compute(int nombre, int pipeMW[2], int pipeWM[2]) {
master.c:  // 1) Envoi
master.c:  if (nombre > last_tested) {
master.c:    for (int i = last_tested + 1; i <= nombre; i++) {
master.c:      write(pipeMW[1], &i, sizeof(i));
master.c:    }
master.c:    last_tested = nombre;
master.c:  } else {
master.c:    write(pipeMW[1], &nombre, sizeof(nombre));
master.c:  }
master.c:
master.c:  // 2) NON BLOQUANT
master.c:  set_nonblocking(pipeWM[0]);
master.c:
master.c:  int msg;
master.c:  int verdict = -1;
master.c:
master.c:  while (1) {
master.c:    ssize_t r = read(pipeWM[0], &msg, sizeof(msg));
master.c:
master.c:    if (r == sizeof(msg)) {
master.c:      if (msg > 0) {
master.c:        // nouveau premier trouvé
master.c:        highest_prime = msg;
master.c:        nb_primes++;
master.c:        printf("[MASTER] Nouveau premier trouvé : %d\n", msg);
master.c:
master.c:        // SUCCESS FINAL → FIN
master.c:        if (msg == nombre) {
master.c:          verdict = nombre;
master.c:          break;
master.c:        }
master.c:      } else if (msg == 0) {
master.c:        // échec final → FIN
master.c:        verdict = 0;
master.c:        break;
master.c:      }
master.c:    } else {
master.c:      // rien à lire → attendre un petit peu
master.c:      sleep(500);
master.c:    }
master.c:  }
master.c:
master.c:  return verdict;
master.c:}
master.c:
master.c:/* ============================================================
master.c: * STOP — envoie -1 dans le pipeline + ferme le worker
master.c: * ============================================================ */
master.c:void order_stop(int pipeMW[2]) {
master.c:  int stop = -1;
master.c:  write(pipeMW[1], &stop, sizeof(stop));
master.c:
master.c:  printf("[MASTER] STOP envoyé dans le pipeline\n");
master.c:}
master.c:
master.c:/* ============================================================
master.c: * Boucle principale
master.c: * ============================================================ */
master.c:void loop(int sem_sync, int pipeMW[2], int pipeWM[2]) {
master.c:  while (1) {
master.c:    printf("[MASTER] Attente d'un client...\n");
master.c:
master.c:    int order = ORDER_NONE;
master.c:    int number = 0;
master.c:
master.c:    // --- Lecture client ---
master.c:    int fdIn = open(FIFO_CLIENT_TO_MASTER, O_RDONLY);
master.c:    read(fdIn, &order, sizeof(order));
master.c:
master.c:    if (order == ORDER_COMPUTE_PRIME) {
master.c:      read(fdIn, &number, sizeof(number));
master.c:      printf("[MASTER] Reçu COMPUTE %d\n", number);
master.c:    } else if (order == ORDER_STOP) {
master.c:      printf("[MASTER] Reçu STOP\n");
master.c:    }
master.c:    close(fdIn);
master.c:
master.c:    // --- Traitement ---
master.c:    int resultat = 0;
master.c:
master.c:    if (order == ORDER_COMPUTE_PRIME) {
master.c:      resultat = order_compute(number, pipeMW, pipeWM);
master.c:    } else if (order == ORDER_HIGHEST_PRIME) {
master.c:      resultat = highest_prime;
master.c:    } else if (order == ORDER_HOW_MANY_PRIME) {
master.c:      resultat = nb_primes;
master.c:    }
master.c:
master.c:    // --- Envoi résultat au client ---
master.c:    int fdOut = open(FIFO_MASTER_TO_CLIENT, O_WRONLY);
master.c:    write(fdOut, &resultat, sizeof(resultat));
master.c:    close(fdOut);
master.c:
master.c:    // --- Attendre que le client ait fini ---
master.c:    P(sem_sync);
master.c:
master.c:    // --- STOP ---
master.c:    if (order == ORDER_STOP) {
master.c:      order_stop(pipeMW);
master.c:      break;
master.c:    }
master.c:  }
master.c:}
master.c:
master.c:/* ============================================================
master.c: * main()
master.c: * ============================================================ */
master.c:int main(int argc, char *argv[]) {
master.c:  printf("[MASTER] Démarrage du master (pipeline Hoare stable)\n");
master.c:
master.c:  createFifos();
master.c:
master.c:  // --- Sémaphores ---
master.c:  key_t key_mutex = ftok("master.c", 'M');
master.c:  key_t key_sync = ftok("master.c", 'S');
master.c:
master.c:  int sem_mutex = semget(key_mutex, 1, IPC_CREAT | 0666);
master.c:  int sem_sync = semget(key_sync, 1, IPC_CREAT | 0666);
master.c:
master.c:  semctl(sem_mutex, 0, SETVAL, 1);  // mutex = libre
master.c:  semctl(sem_sync, 0, SETVAL, 0);   // sync = 0
master.c:
master.c:  // --- Pipes du pipeline ---
master.c:  int pipeMW[2], pipeWM[2];
master.c:  pipe(pipeMW);
master.c:  pipe(pipeWM);
master.c:
master.c:  // --- Créer le worker 2 ---
master.c:  int pid = fork();
master.c:  assert(pid != -1);
master.c:
master.c:  if (pid == 0) {
master.c:    closePipes(pipeMW[1], pipeWM[0]);
master.c:
master.c:    char rStr[10], wStr[10], pStr[10];
master.c:    snprintf(rStr, sizeof(rStr), "%d", pipeMW[0]);
master.c:    snprintf(wStr, sizeof(wStr), "%d", pipeWM[1]);
master.c:    snprintf(pStr, sizeof(pStr), "%d", 2);
master.c:
master.c:    char *args[] = {"worker.o", rStr, wStr, pStr, NULL};
master.c:    execv("./worker.o", args);
master.c:
master.c:    perror("execv");
master.c:    exit(1);
master.c:  }
master.c:
master.c:  // parent
master.c:  closePipes(pipeMW[0], pipeWM[1]);
master.c:
master.c:  loop(sem_sync, pipeMW, pipeWM);
master.c:
master.c:  unlinkPipes();
master.c:  resetSemaphore(sem_mutex, sem_sync);
master.c:
master.c:  printf("[MASTER] Fermeture propre.\n");
master.c:  return 0;
master.c:}
master_client.c:#if defined HAVE_CONFIG_H
master_client.c:#include "config.h"
master_client.c:#endif
master_client.c:
master_client.c:#define _XOPEN_SOURCE
master_client.c:
master_client.c:#include <assert.h>
master_client.c:#include <errno.h>  // <-- pour errno si tu veux gérer les erreurs
master_client.c:#include <stdio.h>
master_client.c:#include <stdlib.h>
master_client.c:#include <sys/ipc.h>
master_client.c:#include <sys/sem.h>
master_client.c:#include <sys/stat.h>  // <-- pour mkfifo()
master_client.c:#include <unistd.h>    // <-- pour close() et unlink()
master_client.c:
master_client.c:#include "master_client.h"
master_client.c:
master_client.c:// sema
master_client.c:void P(int semid) {
master_client.c:  struct sembuf op = {0, -1, 0};
master_client.c:  if (semop(semid, &op, 1) == -1) {
master_client.c:    perror("semop P");
master_client.c:    assert(0);
master_client.c:  }
master_client.c:}
master_client.c:
master_client.c:void V(int semid) {
master_client.c:  struct sembuf op = {0, +1, 0};
master_client.c:  if (semop(semid, &op, 1) == -1) {
master_client.c:    perror("semop V");
master_client.c:    assert(0);
master_client.c:  }
master_client.c:}
master_client.c:
master_client.c:void resetSemaphore(int sem1, int sem2) {
master_client.c:  semctl(sem1, 0, IPC_RMID);
master_client.c:  semctl(sem2, 0, IPC_RMID);
master_client.c:}
master_client.c:
master_client.c:// fonctions éventuelles internes au fichier
master_client.c:void createFifos() {
master_client.c:  mkfifo(FIFO_CLIENT_TO_MASTER, 0666);
master_client.c:  mkfifo(FIFO_MASTER_TO_CLIENT, 0666);
master_client.c:}
master_client.c:
master_client.c:void closePipes(int pipe1, int pipe2) {
master_client.c:  close(pipe1);
master_client.c:  close(pipe2);
master_client.c:}
master_client.c:
master_client.c:void unlinkPipes() {
master_client.c:  unlink(FIFO_CLIENT_TO_MASTER);  // supprimer la FIFO client->master
master_client.c:  unlink(FIFO_MASTER_TO_CLIENT);  // supprimer la FIFO master->client
master_client.c:}
master_client.c:
master_client.c:/* client */
master_client.c:void clientInterpretOrder(int order, int number, int resultat) {
master_client.c:  switch (order) {
master_client.c:    case ORDER_COMPUTE_PRIME:
master_client.c:      if (resultat)
master_client.c:        printf("[CLIENT] %d est premier\n", number);
master_client.c:      else
master_client.c:        printf("[CLIENT] %d n'est pas premier\n", number);
master_client.c:      break;
master_client.c:
master_client.c:    case ORDER_HOW_MANY_PRIME:
master_client.c:      printf("[CLIENT] %d nombres premiers ont été trouvés\n", resultat);
master_client.c:      break;
master_client.c:
master_client.c:    case ORDER_HIGHEST_PRIME:
master_client.c:      printf("[CLIENT] Le plus grand nombre premier trouvé est %d\n", resultat);
master_client.c:      break;
master_client.c:
master_client.c:    case ORDER_STOP:
master_client.c:      printf("[CLIENT] Master arrêté (code retour %d)\n", resultat);
master_client.c:      break;
master_client.c:
master_client.c:    default:
master_client.c:      printf("[CLIENT] Ordre inconnu (%d), résultat brut = %d\n", order,
master_client.c:             resultat);
master_client.c:      break;
master_client.c:  }
master_client.c:}
master_client.c:
master_client.c:void clientSendOrder(int fdOut, int order, int number) {
master_client.c:  // Envoi ordre
master_client.c:  if (write(fdOut, &order, sizeof(order)) != sizeof(order)) {
master_client.c:    perror("[CLIENT] write ordre");
master_client.c:    return;
master_client.c:  }
master_client.c:
master_client.c:  // Envoi paramètre si nécessaire
master_client.c:  if (order == ORDER_COMPUTE_PRIME) {
master_client.c:    if (write(fdOut, &number, sizeof(number)) != sizeof(number)) {
master_client.c:      perror("[CLIENT] write number");
master_client.c:      return;
master_client.c:    }
master_client.c:    printf("[CLIENT] Envoi de l'ordre COMPUTE pour %d au master\n", number);
master_client.c:  }
master_client.c:
master_client.c:  else if (order == ORDER_STOP) {
master_client.c:    printf("[CLIENT] Envoi de l'ordre STOP au master\n");
master_client.c:  }
master_client.c:
master_client.c:  else if (order == ORDER_HOW_MANY_PRIME) {
master_client.c:    printf("[CLIENT] Envoi HOW_MANY au master\n");
master_client.c:  }
master_client.c:
master_client.c:  else if (order == ORDER_HIGHEST_PRIME) {
master_client.c:    printf("[CLIENT] Envoi HIGHEST au master\n");
master_client.c:  }
master_client.c:}
master_client.c:
master_client.c:// fonctions éventuelles proposées dans le .h
master_client.h:#ifndef CLIENT_CRIBLE
master_client.h:#define CLIENT_CRIBLE
master_client.h:
master_client.h:// On peut mettre ici des éléments propres au couple master/client :
master_client.h://    - des constantes pour rendre plus lisible les comunications
master_client.h://    - des fonctions communes (création tubes, écriture dans un tube,
master_client.h://      manipulation de sémaphores, ...)
master_client.h:
master_client.h:// ordres possibles pour le master
master_client.h:#define ORDER_NONE 0
master_client.h:#define ORDER_STOP -1
master_client.h:#define ORDER_COMPUTE_PRIME 1
master_client.h:#define ORDER_HOW_MANY_PRIME 2
master_client.h:#define ORDER_HIGHEST_PRIME 3
master_client.h:#define ORDER_COMPUTE_PRIME_LOCAL 4  // ne concerne pas le master
master_client.h:
master_client.h:
master_client.h:#define FIFO_CLIENT_TO_MASTER "client_to_master.fifo"
master_client.h:#define FIFO_MASTER_TO_CLIENT "master_to_client.fifo"
master_client.h:
master_client.h:void V(int semid);
master_client.h:void P(int semid);
master_client.h:void resetSemaphore(int sem1, int sem2);
master_client.h:void createFifos();
master_client.h:void closePipes(int pipe1, int pipe2);
master_client.h:void unlinkPipes();
master_client.h:void clientInterpretOrder(int order, int number, int resultat);
master_client.h:void clientSendOrder(int fdOut, int order, int number);
master_client.h:
master_client.h:// bref n'hésitez à mettre nombre de fonctions avec des noms explicites
master_client.h:// pour masquer l'implémentation
master_client.h:
master_client.h:#endif
master_worker.c:#if defined HAVE_CONFIG_H
master_worker.c:#include "config.h"
master_worker.c:#endif
master_worker.c:
master_worker.c:#include <stdlib.h>
master_worker.c:#include <stdio.h>
master_worker.c:
master_worker.c:#include "master_worker.h"
master_worker.c:
master_worker.c:// fonctions éventuelles internes au fichier
master_worker.c:
master_worker.c:// fonctions éventuelles proposées dans le .h
master_worker.h:#ifndef MASTER_WORKER_H
master_worker.h:#define MASTER_WORKER_H
master_worker.h:
master_worker.h:// On peut mettre ici des éléments propres au couple master/worker :
master_worker.h://    - des constantes pour rendre plus lisible les comunications
master_worker.h://    - des fonctions communes (écriture dans un tube, ...)
master_worker.h:
master_worker.h:
master_worker.h:#endif
worker.c:// worker.c — worker du crible de Hoare (pipeline dynamique)
worker.c:
worker.c:#include <assert.h>
worker.c:#include <fcntl.h>
worker.c:#include <stdio.h>
worker.c:#include <stdlib.h>
worker.c:#include <sys/wait.h>
worker.c:#include <unistd.h>
worker.c:
worker.c:#include "master_worker.h"
worker.c:
worker.c:static void usage(const char *exe, const char *msg) {
worker.c:  fprintf(stderr, "usage : %s <fdRead> <fdWriteMaster> <prime>\n", exe);
worker.c:  if (msg) fprintf(stderr, "message : %s\n", msg);
worker.c:  exit(EXIT_FAILURE);
worker.c:}
worker.c:
worker.c:static void parseArgs(int argc, char *argv[]) {
worker.c:  if (argc != 4) usage(argv[0], "Nombre d’arguments incorrect");
worker.c:}
worker.c:
worker.c:/* =====================================================================
worker.c: * Boucle principale d’un worker du crible Hoare
worker.c: * ===================================================================== */
worker.c:void loop(int fdRead, int *hasNext, int nextPipe[2], int fdWriteMaster,
worker.c:          int myPrime, int *nextPid) {
worker.c:  while (1) {
worker.c:    int n = 0;
worker.c:    int r = read(fdRead, &n, sizeof(int));
worker.c:
worker.c:    if (r == 0) break;
worker.c:    if (r != sizeof(int)) {
worker.c:      perror("[WORKER] read");
worker.c:      break;
worker.c:    }
worker.c:
worker.c:    /* --- CAS STOP --- */
worker.c:    if (n == -1) {
worker.c:      if (*hasNext) {
worker.c:        write(nextPipe[1], &n, sizeof(int));
worker.c:        close(nextPipe[1]);
worker.c:        waitpid(*nextPid, NULL, 0);
worker.c:      }
worker.c:
worker.c:      printf("[WORKER %d] reçoit STOP\n", myPrime);
worker.c:      break;
worker.c:    }
worker.c:
worker.c:    /* --- CAS N == PRIME : SUCCÈS --- */
worker.c:    if (n == myPrime) {
worker.c:      write(fdWriteMaster, &n, sizeof(int));
worker.c:      continue;
worker.c:    }
worker.c:
worker.c:    /* --- CAS divisible : ÉCHEC --- */
worker.c:    if (n % myPrime == 0) {
worker.c:      int fail = 0;
worker.c:      write(fdWriteMaster, &fail, sizeof(int));
worker.c:      continue;
worker.c:    }
worker.c:
worker.c:    /* --- CAS N NON DIVISIBLE : transmettre au suivant --- */
worker.c:    if (!(*hasNext)) {
worker.c:      *hasNext = 1;
worker.c:      assert(pipe(nextPipe) == 0);
worker.c:
worker.c:      *nextPid = fork();
worker.c:      assert(*nextPid != -1);
worker.c:
worker.c:      if (*nextPid == 0) {
worker.c:        close(nextPipe[1]);
worker.c:
worker.c:        char fdReadStr[10], fdWriteStr[10], primeStr[10];
worker.c:        snprintf(fdReadStr, sizeof(fdReadStr), "%d", nextPipe[0]);
worker.c:        snprintf(fdWriteStr, sizeof(fdWriteStr), "%d", fdWriteMaster);
worker.c:        snprintf(primeStr, sizeof(primeStr), "%d", n);
worker.c:
worker.c:        char *args[] = {"worker.o", fdReadStr, fdWriteStr, primeStr, NULL};
worker.c:        execv("./worker.o", args);
worker.c:        perror("execv");
worker.c:        exit(EXIT_FAILURE);
worker.c:      }
worker.c:
worker.c:      close(nextPipe[0]);
worker.c:      printf("[WORKER %d] a créé worker %d (pid=%d)\n", myPrime, n, *nextPid);
worker.c:
worker.c:    } else {
worker.c:      write(nextPipe[1], &n, sizeof(int));
worker.c:    }
worker.c:  }
worker.c:}
worker.c:
worker.c:/* =====================================================================
worker.c: * MAIN
worker.c: * ===================================================================== */
worker.c:int main(int argc, char *argv[]) {
worker.c:  parseArgs(argc, argv);
worker.c:
worker.c:  int fdRead = atoi(argv[1]);
worker.c:  int fdWriteMaster = atoi(argv[2]);
worker.c:  int myPrime = atoi(argv[3]);
worker.c:
worker.c:  printf("[WORKER] (pid=%d) : gère %d\n", getpid(), myPrime);
worker.c:
worker.c:  /* Au démarrage, un worker renvoie immédiatement son premier au master */
worker.c:  write(fdWriteMaster, &myPrime, sizeof(myPrime));
worker.c:
worker.c:  int nextPipe[2] = {-1, -1};
worker.c:  int nextPid = -1;
worker.c:  int hasNext = 0;
worker.c:
worker.c:  loop(fdRead, &hasNext, nextPipe, fdWriteMaster, myPrime, &nextPid);
worker.c:
worker.c:  if (hasNext) {
worker.c:    close(nextPipe[1]);
worker.c:    waitpid(nextPid, NULL, 0);
worker.c:  }
worker.c:
worker.c:  printf("[WORKER %d] (pid=%d) : terminé\n", myPrime, getpid());
worker.c:
worker.c:  return EXIT_SUCCESS;
worker.c:}
